<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anonymous API Credits: A Proposal</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        header {
            border-bottom: 1px solid #eee;
            padding-bottom: 20px;
            margin-bottom: 20px;
        }
        h1 {
            color: #2c3e50;
        }
        h2 {
            color: #3498db;
            margin-top: 30px;
        }
        .disclaimer {
            background-color: #f8f9fa;
            padding: 10px 15px;
            border-left: 4px solid #6c757d;
            margin-bottom: 20px;
            font-style: italic;
        }
        code {
            font-family: 'Courier New', Courier, monospace;
            background-color: #f5f5f5;
            padding: 2px 4px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <header>
        <h1>Anonymous API Credits</h1>
        <div class="disclaimer">
            <p><strong>Disclaimer:</strong> This is a personal proposal and does not represent the views of my employer, Google.</p>
        </div>
    </header>

    <main>
        <h2>Objective</h2>
        <p>Allow anonymous, paid usage of APIs.</p>

        <h2>Background</h2>
        <p>Across the Software-as-a-Service industry, businesses sell access to their services via API credits. This means that an API user will come to some portal, create an API key, then fund that API key with credits. When they use their credits, they provide their API key in a header, and their account is docked on the backend by a certain number of credits.</p>
        
        <p>Due to providing the same API key every time they access the service, they reveal their identity each time, and their different usage of the API can be linked together by the API provider. In some cases, usage of APIs can be extremely sensitive. For instance, when one is talking to a Large Language Model (LLM), one might divulge personal information, secrets, or any other identifying information.</p>
        
        <p>It would be valuable to build approaches that allow users to use LLMs and other web APIs in anonymous ways. Further, LLM-based agents can use this approach to access varying services without revealing their identity, which is especially valuable when they are representing a user in some capacity.</p>

        <h2>Requirements</h2>
        <ul>
            <li>Issuers should be confident that credits cannot be spent more than once.</li>
            <li>Issuers should be confident that the total number of credits issued is always greater than or equal to the quantity of credits spent.</li>
            <li>Clients should be confident that their spends cannot be correlated to their issuances or previous spends with high probability. In particular, assuming there are multiple unspent credit tokens with greater than or equal to c credits, it should be impossible for an issuer to guess which of these unspent tokens was used when c tokens are spent.</li>
        </ul>

        <h2>Design Ideas</h2>
        <p>An anonymous API credit scheme consists of three protocols:</p>
        
        <h3>1. KeyGen</h3>
        <p>An algorithm run by the issuer to generate a new, random keypair.</p>
        
        <h3>2. Issue</h3>
        <p>A protocol run between the issuer and client to issue a new credit token. This protocol is a three step process consisting of three algorithms:</p>
        <ul>
            <li><strong>IssueRequest:</strong> run by the client to create an issuance request</li>
            <li><strong>IssueResponse:</strong> run by the issuer to respond to an issuance request</li>
            <li><strong>IssuanceCredits:</strong> run by the client to create a Credit Token from the response</li>
        </ul>
        
        <h3>3. Spend</h3>
        <p>A protocol run between the issuer and client to spend an existing credit token and create a new one with the remaining balance of the previous token less the amount of credits spent. This protocol is a three step process consisting of three algorithms:</p>
        <ul>
            <li><strong>ProveSpend:</strong> run by the client to prove that they are capable of spending the credits in question and that they haven't spent this Credit Token before</li>
            <li><strong>Refund:</strong> run by the issuer to verify the proofs and refund the unspent credits to a new Credit Token</li>
            <li><strong>RefundCredits:</strong> run by the client to construct a new Credit Token with the remaining balance of Credit Tokens they've left unspent</li>
        </ul>

        <h2>Implementation Approach</h2>
        <p>In order to implement this, we use BBS signatures. First, the issuer generates a BBS keypair. For issuance, the issuer issues a signature of (n, k, r), where k, r are random values generated by the client (hidden from the issuer) and n is the amount of credits you've been issued (visible to the issuer).</p>
        
        <p>The client must ensure that k has never been used before, which they can assure with extremely high probability by generating it randomly. When you spend the credits, you create a new k', r', reveal k, v = h0<sup>m</sup>h1<sup>k'</sup>h2<sup>r'</sup>, and the amount of credits you want to spend, c, and you prove that there exist n, k', r', as well as a signature of (n, k, r), such that n >= c, that m = n - c, and v = h0<sup>m</sup>h1<sup>k'</sup>h2<sup>r'</sup>.</p>
        
        <p>The server first verifies your proof, then checks that it hasn't seen k before, then sends you back a signature of (m, k', r'), which is enabled because you sent h0<sup>m</sup>h1<sup>k'</sup>h2<sup>r'</sup>, as the signature is a function of that value. Revealing k prevents double spending money already spent, however the amount of credits you have left can never be seen.</p>
        
        <p>There are other nice-to-have features of such a system, like combining tokens and splitting tokens, so the credits can be more fungible. These features can be implemented in this approach as well, though I won't describe them here.</p>
        
        <p>Because these credits are issued by the same party which spends it, these proofs can be privately verifiable if desired.</p>
    </main>
</body>
</html>